import {
  SQS_TN_MIGRATION,
  SQS_REGION
} from "./constants";
import AWS from "aws-sdk";
import {
  ISQSSourceData,
  ISQSStepMessage,
  ISQSWorkflowCompleteMessage,
  ISQSResponse
} from "./interfaces";
import { v4 as uuidv4 } from "uuid";
import { AcademySteps, CommonSteps, Templates, BravoSteps, Status, FinishWorkflow, Constants } from "./enums";

export const tnMigrationMessagesSDK = () => {
  AWS.config.update({
    region: SQS_REGION
  });
  const sqs = new AWS.SQS();

  /**
   * Creates a Migration Process via triggering SQS
   * @param tnDid string - A valid TNDID
   * @returns Success or Failure for process creation trigger in ISQSResponse format
   */
  const createProcess = async (tnDid: string) => {
    try {
      if (!tnDid) {
        // To-Do throw err;
      }
      const sqsMessage: ISQSStepMessage = {
        name: CommonSteps.Create,
        process_id: UUID(),
        data: {
          tn_did: tnDid,
          status: Status.New
        }
      };
      return await send(JSON.stringify(sqsMessage), sqsMessage?.process_id);
    } catch (err) {
      // To-Do
    }
  }

  /**
   * Creates a Migration Completion Process via triggering SQS
   * @param processId string - A valid processId to continue
   * @param data ISQSSourceData - A valid tn_did, source_domain and target_domain are required
   * @returns Success or Failure for process creation trigger in ISQSResponse format
   */
  const createFinishProcess = async (processId: string, data: ISQSSourceData) => {
    try {
      if (!processId || !data.tn_did || !data.source_domain || !data.target_domain) {
        // To-Do throw err;
      }
      const sqsMessage: ISQSStepMessage = {
        name: CommonSteps.FinishStart,
        process_id: processId,
        data: {
          ...data,
          status: Status.New
        }
      };
      return await send(JSON.stringify(sqsMessage), sqsMessage?.process_id);
    } catch (err) {
      // To-Do
    }
  }

  /**
   * Creates an SQS to run (retry or input) a specific Process Step
   *
   * @remarks
   * Keep this consistent with the response from TN Resource SDK for now.
   * We can export an Interface, if required.
   *
   * @param data {} - Step data of the process step requiring a re-run
   * @param status Status - Step status, set for manual re-runs (ex input, retry)
   * @returns Success or Failure for process step trigger in ISQSResponse format
   */
  const runProcessStep = async (stepData: { [key: string]: any }, status?: Status) => {
    try {
      const sqsMessage: ISQSStepMessage = {
        name: stepData?.name,
        process_id: stepData?.process_id,
        data: {
          ...stepData?.data,
          status: status || Status.New
        }
      };
      if (stepData?.id) {
        sqsMessage.step_id = stepData?.id;
      }
      return await send(JSON.stringify(sqsMessage), sqsMessage?.process_id);
    } catch (err) {
      // To-Do
    }
  }

  /**
   * Basic Mapper to create a ISQSStepMessage SQS from ISQSWorkflowCompleteMessage
   * @param message ISQSWorkflowStepCompleteMessage
   * @param targetStepId string - Step UUID for the next step
   * @return ISQSStepMessage generated from ISQSWorkflowCompleteMessage
   */
  const mapWorkflowToStep = (message: ISQSWorkflowCompleteMessage, targetStepId: string): ISQSStepMessage => {
    try {
      const sqsMessage: ISQSStepMessage = {
        name: message?.source_name,
        process_id: message?.source_data?.process_id,
        data: message?.source_data?.data,
      };
      if (targetStepId) {
        sqsMessage.step_id = targetStepId;
      }
      return sqsMessage;
    } catch (err) {
      // To-Do
    }
  }

  /**
   * Generates a IStepMessage SQS in the Queue from ISQSWorkflowCompleteMessage
   * @param data ISQSWorkflowStepCompleteMessage
   * @param targetStepId string - Step UUID for the next step
   * @return Success or Failure for process step initialization in ISQSResponse format
   */
  const sendStepMessage = async (message: ISQSWorkflowCompleteMessage, targetStepId: string) => {
    try {
      const finishWorkflow = isSupportedFinishWorkflowAction(message?.source_data?.data?.finish_workflow) ?
        message?.source_data?.data?.finish_workflow : null;
      const nextStep = getNextStep(message?.source_name, message?.source_data?.data?.template, finishWorkflow);
      if (nextStep === CommonSteps.Unknown) {
        // To-Do throw err;
      }
      const sqsMessage: ISQSStepMessage = {
        name: nextStep,
        process_id: message?.source_data?.process_id,
        step_id: targetStepId,
        data: {
          tn_did: message?.source_data?.data?.tn_did,
          status: message?.source_data?.data?.status || Status.New,
        },
      };
      if (message?.source_data?.data?.source_domain) {
        sqsMessage.data.source_domain = message.source_data.data.source_domain;
      }
      if (message?.source_data?.data?.target_domain) {
        sqsMessage.data.target_domain = message.source_data.data.target_domain;
      }
      if (message?.source_data?.data?.template) {
        sqsMessage.data.template = message.source_data.data.template;
      }
      if (message?.source_data?.data?.finish_workflow) {
        sqsMessage.data.finish_workflow = message.source_data.data.finish_workflow;
      }
      return await send(JSON.stringify(sqsMessage), sqsMessage?.process_id);
    } catch (err) {
      // To-Do
    }
  };

  /**
   * Generates a ISQSWorkflowCompleteMessage SQS in the Queue from IStepMessage
   * @param data ISQSWorkflowStepCompleteMessage
   * @return Success or Failure for workflow step initialization in ISQSResponse format
   */
  const sendWorkflowMessage = async (message: ISQSStepMessage) => {
    try {
      const sqsMessage: ISQSWorkflowCompleteMessage = {
        name: Constants.workflowComplete,
        workflow: Constants.tnMigrateV3,
        source_name: message?.name,
        source_id: message?.step_id,
        source_data: {
          process_id: message?.process_id,
          data: message?.data
        }
      };
      return await send(JSON.stringify(sqsMessage), message?.process_id);
    } catch (err) {
      // To-Do
    }
  };

  /**
   * Identifies the next step name from the current step name
   * @param currentStep string - Current Step Name
   * @param template string [optional] - Should be added for identification for common steps like Create
   * @param finishWorkflowAction string [optional] - Should be added for the finish actions only
   * @returns Returns the complete action name for the next step
   */
  const getNextStep = (currentStep: string, template?: string, finishWorkflowAction?: FinishWorkflow): string => {
    let _template: Templates;
    if (template === Templates.Academy || currentStep.includes(Templates.Academy)) {
      _template = Templates.Academy;
    } else if (template === Templates.Bravo || currentStep.includes(Templates.Bravo)) {
      _template = Templates.Bravo;
    } else {
      _template = Templates.Unsupported;
    }
    if (currentStep && !finishWorkflowAction) {
      if (_template === Templates.Academy) {
        switch (currentStep) {
          case CommonSteps.Create:
            return AcademySteps.Start;
          case AcademySteps.Start:
            return AcademySteps.Domain;
          case AcademySteps.Domain:
            return AcademySteps.BaseCopy;
          case AcademySteps.BaseCopy:
            return AcademySteps.LandingCopy;
          case AcademySteps.LandingCopy:
            return AcademySteps.CustomContentCopy;
          case AcademySteps.CustomContentCopy:
            return AcademySteps.FeaturedPageCopy;
          case AcademySteps.FeaturedPageCopy:
            return AcademySteps.SocialCopy;
          case AcademySteps.SocialCopy:
            return AcademySteps.PpTcCopy;
          case AcademySteps.PpTcCopy:
            return AcademySteps.JoinContentCopy;
          case AcademySteps.JoinContentCopy:
            return AcademySteps.NavigationCopy;
          case AcademySteps.NavigationCopy:
            return CommonSteps.Complete;
          default:
            return AcademySteps.Unknown;
        }
      } else if (_template === Templates.Bravo) {
        switch (currentStep) {
          case CommonSteps.Create:
            return BravoSteps.Start;
          case BravoSteps.Start:
            return BravoSteps.Domain;
          case BravoSteps.Domain:
            return BravoSteps.BaseCopy;
          case BravoSteps.BaseCopy:
            return BravoSteps.SocialCopy;
          case BravoSteps.SocialCopy:
            return BravoSteps.JoinContentCopy;
          case BravoSteps.JoinContentCopy:
            return BravoSteps.NavigationCopy;
          case BravoSteps.NavigationCopy:
            return CommonSteps.Complete;
          default:
            return BravoSteps.Unknown;
        }
      }
    } else if (currentStep && finishWorkflowAction) {
      switch (currentStep) {
        case CommonSteps.FinishStart:
          switch (finishWorkflowAction) {
            case FinishWorkflow.Redirect:
              return CommonSteps.Redirect;
            case FinishWorkflow.Subdomain:
              return CommonSteps.Redirect;
            case FinishWorkflow.Vanity:
              return CommonSteps.CompleteVanity;
            default:
              return CommonSteps.Unknown;
          }
        case CommonSteps.Redirect:
        case CommonSteps.CompleteVanity:
          return CommonSteps.Complete;
        default:
          return CommonSteps.Unknown;
      }
    }
    return CommonSteps.Unknown;
  }

  /**
   * Method can used to send a message to the SQS_TN_MIGRATION Queue
   *
   * @remarks
   * In the Migration workflow, you shouldn't have the need to use this method directly anywhere.
   * Prefer the usage of wrappers provided for automatic handling and processing of data.
   *
   * @param message string - Stringified format of the SQS message to send
   * @param messageGroupId string - This tag specifies that a message belongs to a specific message group.
   * @returns The success or failure response adhereing to ISQSResponse interface
   */
  const send = async (message: string, messageGroupId: string): Promise<ISQSResponse> => {
    try {
      if (!messageGroupId) {
        throw new Error(`Invalid Message Group ID`);
      }
      const params: AWS.SQS.SendMessageRequest = {
        MessageBody: message,
        QueueUrl: SQS_TN_MIGRATION,
        MessageGroupId: messageGroupId
      };
      const publishMessage = await sqs.sendMessage(params).promise();
      const res: ISQSResponse = {
        status: Constants.success,
        metadata: publishMessage
      }
      return res;
    } catch (err) {
      const res: ISQSResponse = {
        status: Constants.failure,
        metadata: err
      };
      throw res;
    }
  }

  /**
   * @internal
   * Checks if Finish Workflow enum supports an action
   * @param action FinishWorkflow - Action name for which support needs to be checked
   * @returns Boolean to specify if the action is supported
   */
  const isSupportedFinishWorkflowAction = (action: FinishWorkflow): boolean => {
    if (action && Object.values(FinishWorkflow).includes(action)) {
      return true;
    }
    return false;
  }

  /**
   * @internal
   * Generated a UUID using uuidv4 package
   * @returns Returns the generated unique id
   */
  const UUID = (): string => {
    const token = uuidv4();
    return token;
  }

  return {
    createProcess,
    createFinishProcess,
    runProcessStep,
    sendWorkflowMessage,
    sendStepMessage,
    getNextStep,
    send,
    mapWorkflowToStep
  };
}
